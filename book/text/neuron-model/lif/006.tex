いくつかの処理について解説しておく．まず，一番目のforループ内の\jl{v[i]}の\jl{((dt*tcount) > (tlast[i] + tref))}は最後にニューロンが発火した時刻\jl{tlast[i]}に不応期\jl{tref}を足した時刻よりも現在の時刻\jl{dt*tcount[1]}が大きければ膜電位の更新を許可し，小さければ更新しない．二番目のforループにおける\jl{fire[i]}はニューロンの膜電位が閾値電位\jl{vthr}を超えたら\jl{True}となる．\jl{v[i]}などの更新式にある\jl{ifelse(a, b, c)}はaが\jl{True}の時はbを返し，\jl{False}の時はcを返す関数であり，\jl{v[i] = ifelse(fire[i], vreset, v[i])}は\jl{fire[i]}が\jl{True}なら\jl{v[i]}をリセット電位\jl{vreset}とし，そうでなければそのままの値を返すという処理である．同様にして\jl{tlast[i]}は発火したときにその時刻を記録する変数となっている．なお，\jl{v_[i] = ifelse(fire[i], vpeak, v[i])}は実際のシミュレーションにおいて意味をなさない．単に発火時の電位\jl{vpeak}を含めて記録すると描画時の見栄えが良いというだけである．

これらの\jl{struct}と関数を用いてシミュレーションを実行する．\jl{I} はHHモデルのときと同じように矩形波を入力する．実は\jl{I}は入力電流ではなく入力電流に比例する量となっているが，これは膜抵抗を乗じた後の値であると考えるとよい．
